
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
    <title>Game DSL to natural language translations </title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/css/bootstrap.min.css" integrity="sha384-Gn5384xqQ1aoWXA+058RXPxPg6fy4IWvTNh0E263XmFcJlSAwiGgFAW/dAiS6JXm" crossorigin="anonymous">
    
<style>
    .table td, .table th {
        min-width: 40em;
        max-width: 60em;
    }
    pre {
        white-space: pre-wrap;
        max-height: 60em;
        overflow: auto;
        display: inline-block;
    }
</style>

</head>
<body>
    <div>
        <table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </th><th scope="col">Stage 1                                                                                                       </th><th scope="col">Stage 2                                                                                                                                      </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?h - hexagonal_bin ?r - triangular_ramp)<br>    (game-conserved<br>      (near ?h ?r)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin and an object ?r of type triangular_ramp, such that ?h is near ?r                                                                                                               </td><td>In order to set up the game, place a hexagonal bin near a triangular ramp and ensure that this arrangement is maintained throughout the game.</td><td>Setup: place a hexagonal bin near a triangular ramp and ensure that this arrangement is maintained throughout the game.<br><br>Gameplay: hold a ball and throw it so that it touches the triangular ramp during its flight and then lands inside the hexagonal bin.<br><br>Terminal: the game ends after the hexagonal bin has been tipped over at least once without being touched or held by the agent.<br><br>Scoring: your score is the number of times you successfully threw a ball that touched the ramp and landed in the bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwToRampToBin<br>      (exists (?b - ball ?r - triangular_ramp ?h - hexagonal_bin)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold-while (and (not (agent_holds ?b)) (in_motion ?b)) (touch ?b ?r))<br>          (once (and (not (in_motion ?b)) (in ?h ?b)))<br>       )<br>     )<br>   )<br>    (preference binKnockedOver<br>      (exists (?h - hexagonal_bin)<br>        (then<br>          (once (object_orientation ?h upright))<br>          (hold (and (not (touch agent ?h)) (not (agent_holds ?h))))<br>          (once (not (object_orientation ?h upright)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br>    -?r of type triangular_ramp<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion) Additionally, during this sequence there is a state where (?b touches ?r) (in that order).<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where ?h is oriented upright<br>    - next, there is a sequence of one or more states where (it's not the case that agent touches ?h) and (it's not the case that the agent is holding ?h)<br>    - finally, there is a state where it's not the case that ?h is oriented upright                                                                                                               </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball, and during its flight, the ball touches a triangular ramp<br>-finally, the ball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, a hexagonal bin is positioned upright<br>-next, the bin remains untouched and not held by the agent<br>-finally, the bin is no longer in an upright orientation                                                                                                                                              </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (count-once binKnockedOver) 1)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </td><td>The game ends when min(1, the number of times 'Preference 2' has been satisfied) is greater than or equal to 1</td><td>The game ends when Preference 2 has been satisfied at least once                                                                             </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwToRampToBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied           </td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.                                           </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                            </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (and<br>    (exists (?h - hexagonal_bin)<br>      (game-conserved<br>        (adjacent ?h bed)<br>     )<br>   )<br>    (forall (?o - (either teddy_bear pillow))<br>      (game-conserved<br>        (not<br>          (on bed ?o)<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin, such that ?h is adjacent to bed<br>- for any object ?o of type teddy_bear or pillow, it's not the case that ?o is on bed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>In order to set up the game, place a hexagonal bin next to the bed and ensure that it remains there at all times. Additionally, make sure that no teddy bears or pillows are on the bed throughout the duration of the game.                                                                                                                                                                                       </td><td>Setup: Place a hexagonal bin next to the bed and ensure no teddy bears or pillows are on the bed throughout the game.<br><br>Gameplay: Stand next to a desk and throw balls aiming to get them inside the hexagonal bin.<br><br>Scoring: Earn 10 points for each dodgeball, 20 points for each basketball, and 30 points for each beachball that lands in the bin. Subtract 1 point for each ball that does not land in the bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?b - ball)<br>      (and<br>        (preference throwBallToBin<br>          (exists (?h - hexagonal_bin)<br>            (then<br>              (once (and (agent_holds ?b) (adjacent desk agent)))<br>              (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>              (once (and (not (in_motion ?b)) (in ?h ?b)))<br>           )<br>         )<br>       )<br>     )<br>   )<br>    (preference failedThrowToBin<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (and (agent_holds ?b) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (and (not (in_motion ?b)) (not (in ?h ?b))))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?b) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?b) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (it's not the case that ?b is inside of ?h)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball while standing next to a desk<br>-next, the agent throws the ball<br>-finally, the ball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a ball while standing next to a desk<br>-next, the agent throws the ball<br>-finally, the ball stops moving and is not inside a hexagonal bin                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                   </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 10 (count throwBallToBin:dodgeball))<br>    (* 20 (count throwBallToBin:basketball))<br>    (* 30 (count throwBallToBin:beachball))<br>    (- (count failedThrowToBin))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td><td>At the end of the game, the player's score is the sum of (the product of (10) and (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type dodgeball)); (the product of (20) and (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type basketball)); (the product of (30) and (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type beachball)); and (negative the number of times 'Preference 2' has been satisfied)</td><td>At the end of the game, the player's score is calculated by adding together the following points: 10 points for each time Preference 1 has been satisfied with a dodgeball, 20 points for each time Preference 1 has been satisfied with a basketball, and 30 points for each time Preference 1 has been satisfied with a beachball. From this total, subtract the number of times Preference 2 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 1                                                                                                                                                                                              </th><th scope="col">Stage 2                                                                                                                                                                                   </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?h - hexagonal_bin)<br>    (game-conserved<br>      (or<br>        (on bed ?h)<br>        (exists (?w - wall)<br>          (adjacent ?w ?h)<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin, such that (?h is on bed) or (there exists an object ?w of type wall, such that ?w is adjacent to ?h)                                                                                                                                                                                                      </td><td>In order to set up the game, place a hexagonal bin either on the bed or next to a wall and ensure that it remains in one of these positions for the duration of the game.                 </td><td>Setup: place a hexagonal bin either on the bed or next to a wall and ensure it stays there throughout the game.<br><br>Gameplay: hold a dodgeball and throw it into the hexagonal bin without it touching the floor for Preference 1, or with it touching the floor for Preference 2. The bin should be on the bed or adjacent to a wall opposite the wall adjacent to you.<br><br>Scoring: your score is the sum of three times the number of successful throws for Preference 1 and the number of successful throws for Preference 2.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwBallToBin<br>      (exists (?d - dodgeball ?h - hexagonal_bin)<br>        (then<br>          (once (and (agent_holds ?d) (or (on bed ?h) (exists (?w1 ?w2 - wall) (and (adjacent ?w1 ?h) (adjacent ?w2 agent) (opposite ?w1 ?w2))))))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d) (not (touch floor ?d))))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br>    (preference bounceBallToBin<br>      (exists (?d - dodgeball ?h - hexagonal_bin)<br>        (then<br>          (once (and (agent_holds ?d) (or (on bed ?h) (exists (?w1 ?w2 - wall) (and (adjacent ?w1 ?h) (adjacent ?w2 agent) (opposite ?w1 ?w2))))))<br>          (hold-while (and (not (agent_holds ?d)) (in_motion ?d)) (touch floor ?d))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and ((?h is on bed) or (there exists objects ?w1 and ?w2 of type wall, such that (?w1 is adjacent to ?h), (?w2 is adjacent to agent), and (?w1 is opposite ?w2)))<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d), (?d is in motion), and (it's not the case that floor touches ?d)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and ((?h is on bed) or (there exists objects ?w1 and ?w2 of type wall, such that (?w1 is adjacent to ?h), (?w2 is adjacent to agent), and (?w1 is opposite ?w2)))<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion) Additionally, during this sequence there is a state where (floor touches ?d) (in that order).<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)                                                                                                                                                                                                      </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a dodgeball while either the hexagonal bin is on the bed or there are two walls such that one is adjacent to the bin and the other is adjacent to the agent, with the two walls being opposite each other<br>-next, the agent throws the dodgeball in such a way that it does not touch the floor while it is in motion<br>-finally, the dodgeball comes to rest inside the hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a dodgeball while either the hexagonal bin is on the bed or there are two walls such that one is adjacent to the bin and the other is adjacent to the agent, with the two walls being opposite each other<br>-next, the agent throws the dodgeball and during its flight, the dodgeball touches the floor<br>-finally, the dodgeball stops moving and is inside the hexagonal bin                                                                                                                                                                                           </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>                                                                                                                                                                                                     </td><td>                                                                                                                                                                                          </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count bounceBallToBin) (* 3 (count throwBallToBin))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 2' has been satisfied) and (the product of (3) and (the number of times 'Preference 1' has been satisfied))</td><td>At the end of the game, the player's score is calculated by adding the number of times Preference 2 has been satisfied to three times the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </th><th scope="col">Stage 1                                                                                                </th><th scope="col">Stage 2                                                                                           </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td><td>                                                                                                       </td><td>                                                                                                  </td><td>Gameplay: throw teddy bears so that they come to rest on a pillow<br><br>Terminal: the game ends after you've thrown teddy bears at least 10 times<br><br>Scoring: you get 1 point for each teddy bear that stops moving while resting on a pillow          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwTeddyOntoPillow<br>      (exists (?t - teddy_bear ?p - pillow)<br>        (then<br>          (once (agent_holds ?t))<br>          (hold (and (not (agent_holds ?t)) (in_motion ?t)))<br>          (once (and (not (in_motion ?t)) (on ?p ?t)))<br>       )<br>     )<br>   )<br>    (preference throwAttempt<br>      (exists (?t - teddy_bear)<br>        (then<br>          (once (agent_holds ?t))<br>          (hold (and (not (agent_holds ?t)) (in_motion ?t)))<br>          (once (not (in_motion ?t)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?p of type pillow<br>    -?t of type teddy_bear<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?t<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?t) and (?t is in motion)<br>    - finally, there is a state where (it's not the case that ?t is in motion) and (?t is on ?p)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?t of type teddy_bear<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?t<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?t) and (?t is in motion)<br>    - finally, there is a state where it's not the case that ?t is in motion                                                                                                        </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a teddy bear<br>-next, the agent throws the teddy bear<br>-finally, the teddy bear stops moving and is resting on a pillow<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a teddy bear<br>-next, the agent throws the teddy bear<br>-finally, the teddy bear stops moving                                                                                                   </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (count throwAttempt) 10)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td><td>The game ends when the number of times 'Preference 2' has been satisfied is greater than or equal to 10</td><td>The game ends when Preference 2 has been satisfied at least 10 times                              </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwTeddyOntoPillow)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied    </td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 1                                                                                                </th><th scope="col">Stage 2                                                                                           </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>                                                                                                       </td><td>                                                                                                  </td><td>Gameplay: stand on a rug and throw balls into a hexagonal bin<br><br>Terminal: the game ends after you've thrown balls 10 times<br><br>Scoring: your score is the number of successful throws that land inside the hexagonal bin          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwInBin<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (and (on rug agent) (agent_holds ?b)))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (and (not (in_motion ?b)) (in ?h ?b)))<br>       )<br>     )<br>   )<br>    (preference throwAttempt<br>      (exists (?b - ball)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (not (in_motion ?b)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (agent is on rug) and (the agent is holding ?b)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where it's not the case that ?b is in motion                                                                                                        </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is standing on a rug while holding a ball<br>-next, the agent throws the ball<br>-finally, the ball comes to rest inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving                                                                                                   </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (count throwAttempt) 10)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>The game ends when the number of times 'Preference 2' has been satisfied is greater than or equal to 10</td><td>The game ends when Preference 2 has been satisfied at least 10 times                              </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwInBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied    </td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                               </th><th scope="col">Stage 1                                                                                                                                             </th><th scope="col">Stage 2                                                                                                                            </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                      </td><td>                                                                                                                                                    </td><td>                                                                                                                                   </td><td>Gameplay: stack blocks in a specific order with a flat block on a bridge block, a tall cylindrical block on the flat block, a cube block on the tall cylindrical block, and a pyramid block on the cube block.<br><br>Scoring: your score is 10 points for each different set of blocks stacked in the correct order at the end of the game.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference castleBuilt<br>      (exists (?b - bridge_block ?f - flat_block ?t - tall_cylindrical_block ?c - cube_block ?p - pyramid_block)<br>        (at-end<br>          (and<br>            (on ?b ?f)<br>            (on ?f ?t)<br>            (on ?t ?c)<br>            (on ?c ?p)<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type bridge_block<br>    -?c of type cube_block<br>    -?f of type flat_block<br>    -?p of type pyramid_block<br>    -?t of type tall_cylindrical_block<br><br>    This preference is satisfied when:<br>    - in the final game state, (?f is on ?b), (?t is on ?f), (?c is on ?t), and (?p is on ?c)                                                                                                                                                     </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-at the end of the game, the blocks are stacked in a specific order with a flat block on top of a bridge block, a tall cylindrical block on top of the flat block, a cube block on top of the tall cylindrical block, and finally, a pyramid block on top of the cube block.                                                                                                                                    </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                      </td><td>                                                                                                                                                    </td><td>                                                                                                                                   </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (* 10 (count-once-per-objects castleBuilt))<br>)</code></pre>                                                                                                                                                                                                                                                                                                               </td><td>At the end of the game, the player's score is the product of (10) and (the number of times 'Preference 1' has been satisfied with different objects)</td><td>At the end of the game, the player's score is 10 times the number of different objects that have been used to satisfy Preference 1.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                          </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?c - chair)<br>    (game-conserved<br>      (and<br>        (near room_center ?c)<br>        (not<br>          (faces ?c desk)<br>       )<br>        (not<br>          (faces ?c bed)<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?c of type chair, such that (room_center is near ?c), (it's not the case that ?c is facing desk), and (it's not the case that ?c is facing bed)                                                                                                                                                                                                                                                                                                                                  </td><td>In order to set up the game, place a chair near the center of the room and ensure that it is not facing the desk or the bed at any point during the game.                                                                                                                                                                              </td><td>Setup: place a chair near the center of the room, ensuring it does not face the desk or the bed.<br><br>Gameplay: while standing next to a desk, throw dodgeballs aiming to land them inside a hexagonal bin, on the bed, or on the chair that is part of the game setup.<br><br>Terminal: the game ends when the total score is 10 or more.<br><br>Scoring: earn 5 points for each dodgeball that lands in the hexagonal bin, 1 point for each dodgeball that lands on the bed, and 1 point for each dodgeball that lands on the chair. However, lose 1 point for each dodgeball that lands elsewhere.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballThrownToBin<br>      (exists (?d - dodgeball ?h - hexagonal_bin)<br>        (then<br>          (once (and (agent_holds ?d) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br>    (preference ballThrownToBed<br>      (exists (?d - dodgeball)<br>        (then<br>          (once (and (agent_holds ?d) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (on bed ?d)))<br>       )<br>     )<br>   )<br>    (preference ballThrownToChair<br>      (exists (?d - dodgeball ?c - chair)<br>        (then<br>          (once (and (agent_holds ?d) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (on ?c ?d) (is_setup_object ?c)))<br>       )<br>     )<br>   )<br>    (preference ballThrownMissesEverything<br>      (exists (?d - dodgeball)<br>        (then<br>          (once (and (agent_holds ?d) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (not (exists (?h - hexagonal_bin) (in ?h ?d))) (not (on bed ?d)) (not (exists (?c - chair) (and (on ?c ?d) (is_setup_object ?c))))))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is on bed)<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?c of type chair<br>    -?d of type dodgeball<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion), (?d is on ?c), and (?c is used in the setup)<br><br>-----Preference 4-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion); (it's not the case that there exists an object ?h of type hexagonal_bin, such that ?d is inside of ?h); (it's not the case that ?d is on bed); and (it's not the case that there exists an object ?c of type chair, such that (?d is on ?c) and (?c is used in the setup))                                                                                                                                                                                                                                                                                                                                  </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while standing next to a desk<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball comes to rest inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while standing next to a desk<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving and is resting on the bed<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while standing next to a desk<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving, is resting on a chair, and the chair is part of the game setup<br><br>-----Preference 4-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while standing next to a desk<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving and is not inside a hexagonal bin, not on the bed, and not resting on a chair that is part of the game setup                                                                                                                                                                                                                                                                                                                                        </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (total-score) 10)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td><td>The game ends when (total-score) is greater than or equal to 10                                                                                                                                                                                                                                                                  </td><td>The game ends when the total score reaches 10 or more.                                                                                                                                                                                                                                                                                 </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 5 (count ballThrownToBin))<br>    (count ballThrownToBed)<br>    (count ballThrownToChair)<br>    (- (count ballThrownMissesEverything))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td><td>At the end of the game, the player's score is the sum of (the product of (5) and (the number of times 'Preference 1' has been satisfied)), (the number of times 'Preference 2' has been satisfied), (the number of times 'Preference 3' has been satisfied), and (negative the number of times 'Preference 4' has been satisfied)</td><td>At the end of the game, the player's score is calculated by adding together the following: 5 points for each time Preference 1 has been satisfied, 1 point for each time Preference 2 has been satisfied, 1 point for each time Preference 3 has been satisfied, and subtracting 1 point for each time Preference 4 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                             </th><th scope="col">Stage 1                                                                                            </th><th scope="col">Stage 2                                                                                           </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                    </td><td>                                                                                                   </td><td>                                                                                                  </td><td>Gameplay: place objects that are not pillows on the bed<br><br>Scoring: you get 1 point for each different non-pillow object on the bed at the end of the game          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference objectOnBed<br>      (exists (?g - game_object)<br>        (at-end<br>          (and<br>            (not<br>              (same_type ?g pillow)<br>           )<br>            (on bed ?g)<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?g of type game_object<br><br>    This preference is satisfied when:<br>    - in the final game state, (it's not the case that ?g is of the same type as pillow) and (?g is on bed)                                                                                                    </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-at the end of the game, an object that is not a pillow is on the bed                                                                                                   </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                    </td><td>                                                                                                   </td><td>                                                                                                  </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count objectOnBed)<br>)</code></pre>                                                                                                                                                                                                                                                     </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                            </th><th scope="col">Stage 1                                                                                                                   </th><th scope="col">Stage 2                                                                                                                   </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (forall (?g - game_object)<br>    (game-optional<br>      (not<br>        (in top_drawer ?g)<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                     </td><td>In order to set up the game, the following must all be true for at least one time step:<br>- for any object ?g of type game_object, it's not the case that ?g is inside of top_drawer                                                                                                                           </td><td>In order to set up the game, ensure that at some point, no game objects are inside the top drawer.                        </td><td>Setup: Ensure that at some point, the top drawer is empty of any game objects.<br><br>Gameplay: Place objects inside the top drawer and ensure the drawer is closed.<br><br>Scoring: You get 1 point for each different object placed inside the closed top drawer by the end of the game.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference itemInClosedDrawerAtEnd<br>      (exists (?g - game_object)<br>        (at-end<br>          (and<br>            (in top_drawer ?g)<br>            (not<br>              (open top_drawer)<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?g of type game_object<br><br>    This preference is satisfied when:<br>    - in the final game state, (?g is inside of top_drawer) and (it's not the case that top_drawer is open)                                                                                                                           </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-at the end of the game, an object is inside the top drawer and the top drawer is not open                                                                                                                           </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                   </td><td>                                                                                                                          </td><td>                                                                                                                          </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count-once-per-objects itemInClosedDrawerAtEnd)<br>)</code></pre>                                                                                                                                                                                                                                       </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied with different objects</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied using different objects.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </th><th scope="col">Stage 1                                                                                               </th><th scope="col">Stage 2                                                                                                                                                                                         </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (and<br>    (exists (?h - hexagonal_bin)<br>      (game-conserved<br>        (on bed ?h)<br>     )<br>   )<br>    (forall (?d - dodgeball)<br>      (game-optional<br>        (on desk ?d)<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                          </td><td>In order to set up the game, the following must all be true for at least one time step:<br>- for any object ?d of type dodgeball, ?d is on desk<br><br>and in addition, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin, such that ?h is on bed                                                                                                       </td><td>In order to set up the game, place every dodgeball on the desk at least once. Additionally, put a hexagonal bin on the bed and ensure that it remains there for the entire duration of the game.</td><td>Setup: Place every dodgeball on the desk and put a hexagonal bin on the bed, ensuring both remain in place throughout the game.<br><br>Gameplay: While standing next to the desk, throw dodgeballs aiming to get them to rest inside the hexagonal bin.<br><br>Terminal: The game ends after you have thrown dodgeballs at least 5 times.<br><br>Scoring: Your score is the number of successful throws where the dodgeball ends up inside the hexagonal bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwToBin<br>      (exists (?d - dodgeball ?h - hexagonal_bin)<br>        (then<br>          (once (and (agent_holds ?d) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br>    (preference throwAttempt<br>      (exists (?d - dodgeball)<br>        (then<br>          (once (agent_holds ?d))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (not (in_motion ?d)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?d<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where it's not the case that ?d is in motion                                                                                                       </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while standing next to a desk<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball comes to rest inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a dodgeball<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving                                                                                                                                                                                                 </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (count throwAttempt) 5)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>The game ends when the number of times 'Preference 2' has been satisfied is greater than or equal to 5</td><td>The game ends when Preference 2 has been satisfied at least 5 times                                                                                                                             </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwToBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied   </td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.                                                                                              </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                        </th><th scope="col">Stage 1                                                                                            </th><th scope="col">Stage 2                                                                                           </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                               </td><td>                                                                                                   </td><td>                                                                                                  </td><td>Gameplay: throw a ball so that it touches a wall during its flight, and then either catch it or touch it after it has stopped moving.<br><br>Scoring: you get 1 point for each time you successfully complete this action.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballThrownToWallToAgent<br>      (exists (?b - ball ?w - wall)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold-while (and (not (agent_holds ?b)) (in_motion ?b)) (touch ?w ?b))<br>          (once (or (agent_holds ?b) (touch agent ?b)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?w of type wall<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion) Additionally, during this sequence there is a state where (?w touches ?b) (in that order).<br>    - finally, there is a state where (the agent is holding ?b) or (agent touches ?b)                                                                                                    </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball, and during its flight, the ball touches a wall<br>-finally, the agent is either holding the ball again or touches the ball after it has stopped moving                                                                                                   </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                               </td><td>                                                                                                   </td><td>                                                                                                  </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count ballThrownToWallToAgent)<br>)</code></pre>                                                                                                                                                                                                                                                                                                    </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?r - curved_wooden_ramp)<br>    (game-conserved<br>      (adjacent ?r rug)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                          </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?r of type curved_wooden_ramp, such that ?r is adjacent to rug                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>In order to set up the game, place a curved wooden ramp next to the rug and ensure that it remains there for the entire duration of the game.                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>Setup: place a curved wooden ramp next to the rug and ensure that it remains there for the entire duration of the game.<br><br>Gameplay: hold a beachball, throw it so that it rolls on the curved wooden ramp, and ensure it comes to rest on the rug where the color underneath matches a specified color.<br><br>Scoring: earn points based on the color of the rug under the beachball when it comes to rest: 1 point for pink, 2 points for yellow, 3 points for orange, 3 points for green, and 4 points for purple. However, lose 1 point for each time the beachball rests on a white section of the rug.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?x - color)<br>      (and<br>        (preference ballRolledOnRampToRug<br>          (exists (?b - beachball ?r - curved_wooden_ramp)<br>            (then<br>              (once (agent_holds ?b))<br>              (hold-while (and (not (agent_holds ?b)) (in_motion ?b)) (on ?r ?b))<br>              (once (and (not (in_motion ?b)) (on rug ?b) (rug_color_under ?b ?x)))<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?x of type color<br>    -?b of type beachball<br>    -?r of type curved_wooden_ramp<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion) Additionally, during this sequence there is a state where (?b is on ?r) (in that order).<br>    - finally, there is a state where (it's not the case that ?b is in motion), (?b is on rug), and (the color of the rug under ?b is ?x)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a beachball<br>-next, the agent throws the beachball, and during its motion, the beachball rolls on a curved wooden ramp<br>-finally, the beachball comes to rest on a rug, and the color of the rug under the beachball matches a specified color                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count ballRolledOnRampToRug:pink) (* 2 (count ballRolledOnRampToRug:yellow))<br>    (* 3 (count ballRolledOnRampToRug:orange))<br>    (* 3 (count ballRolledOnRampToRug:green))<br>    (* 4 (count ballRolledOnRampToRug:purple))<br>    (- (count ballRolledOnRampToRug:white))<br> )<br>)</code></pre>                                                                                                                                                                               </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type pink); (the product of (2) and (the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type yellow)); (the product of (3) and (the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type orange)); (the product of (3) and (the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type green)); (the product of (4) and (the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type purple)); and (negative the number of times 'Preference 1' has been satisfied, where ?x is bound to an object of type white)</td><td>At the end of the game, the player's score is calculated by adding the following: 1 point for each time Preference 1 is satisfied with a pink object, 2 points for each time Preference 1 is satisfied with a yellow object, 3 points for each time Preference 1 is satisfied with an orange object, 3 points for each time Preference 1 is satisfied with a green object, and 4 points for each time Preference 1 is satisfied with a purple object. However, the player loses 1 point for each time Preference 1 is satisfied with a white object.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?d - doggie_bed)<br>    (game-conserved<br>      (near room_center ?d)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?d of type doggie_bed, such that room_center is near ?d                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>In order to set up the game, place a doggie bed near the center of the room and ensure that it remains there for the duration of the game.                                                                                                                                                                                                                                                                                                                                                                                                                             </td><td>Setup: place a doggie bed near the center of the room and ensure that it remains there for the duration of the game.<br><br>Gameplay: throw balls towards the doggie bed, aiming to either land them directly on it without touching any walls or have them touch a wall before landing on the bed.<br><br>Scoring: you earn points based on the type of ball used and how it lands on the doggie bed. For balls that land on the bed without touching any walls, you get 1 point for a basketball, 2 points for a beachball, and 3 points for a dodgeball. For balls that touch a wall before landing on the bed, you get 2 points for a basketball, 3 points for a beachball, and 4 points for a dodgeball.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?b - ball)<br>      (and<br>        (preference throwBallToDoggieBed<br>          (exists (?d - doggie_bed)<br>            (then<br>              (once (agent_holds ?b))<br>              (hold (and (not (agent_holds ?b)) (in_motion ?b) (not (exists (?w - wall) (touch ?w ?b)))))<br>              (once (and (not (in_motion ?b)) (on ?d ?b)))<br>           )<br>         )<br>       )<br>        (preference throwBallToDoggieBedOffWall<br>          (exists (?d - doggie_bed ?w - wall)<br>            (then<br>              (once (agent_holds ?b))<br>              (hold-while (and (not (agent_holds ?d)) (in_motion ?b)) (touch ?w ?b))<br>              (once (and (not (in_motion ?b)) (on ?d ?b)))<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?d of type doggie_bed<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b); (?b is in motion); and (it's not the case that there exists an object ?w of type wall, such that ?w touches ?b)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is on ?d)<br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?d of type doggie_bed<br>    -?w of type wall<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?b is in motion) Additionally, during this sequence there is a state where (?w touches ?b) (in that order).<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is on ?d)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball without it touching any walls during its flight<br>-finally, the ball stops moving and rests on a doggie bed<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball, and during its flight, the ball touches a wall<br>-finally, the ball stops moving and is on a doggie bed                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count throwBallToDoggieBed:basketball) (* 2 (count throwBallToDoggieBed:beachball))<br>    (* 3 (count throwBallToDoggieBed:dodgeball))<br>    (* 2 (count throwBallToDoggieBedOffWall:basketball))<br>    (* 3 (count throwBallToDoggieBedOffWall:beachball))<br>    (* 4 (count throwBallToDoggieBedOffWall:dodgeball))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type basketball); (the product of (2) and (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type beachball)); (the product of (3) and (the number of times 'Preference 1' has been satisfied, where ?b is bound to an object of type dodgeball)); (the product of (2) and (the number of times 'Preference 1OffWall' has been satisfied, where ?b is bound to an object of type basketball)); (the product of (3) and (the number of times 'Preference 1OffWall' has been satisfied, where ?b is bound to an object of type beachball)); and (the product of (4) and (the number of times 'Preference 1OffWall' has been satisfied, where ?b is bound to an object of type dodgeball))</td><td>At the end of the game, the player's score is calculated by adding the following points: 1 point for each time Preference 1 is satisfied with a basketball, 2 points for each time Preference 1 is satisfied with a beachball, and 3 points for each time Preference 1 is satisfied with a dodgeball. Additionally, the player earns 2 points for each time Preference 1OffWall is satisfied with a basketball, 3 points for each time Preference 1OffWall is satisfied with a beachball, and 4 points for each time Preference 1OffWall is satisfied with a dodgeball.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </th><th scope="col">Stage 1                                                                                                                                                                              </th><th scope="col">Stage 2                                                                                                                                                                                         </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?c - curved_wooden_ramp)<br>    (game-conserved<br>      (near room_center ?c)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?c of type curved_wooden_ramp, such that room_center is near ?c                                                                                                                                                                                      </td><td>In order to set up the game, place a curved wooden ramp near the center of the room and ensure that it remains there for the entire duration of the game.                                       </td><td>Setup: place a curved wooden ramp near the center of the room and ensure it stays there throughout the game.<br><br>Gameplay: hold a pink dodgeball, face the curved wooden ramp, and throw the dodgeball so that it touches the ramp during its flight and then either stops on the bed or touches you without being held.<br><br>Scoring: your score is the number of times the dodgeball stops on the bed minus the number of times it touches you without being held after touching the ramp.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballThrownToRampToBed<br>      (exists (?d - dodgeball_pink ?c - curved_wooden_ramp)<br>        (then<br>          (once (and (agent_holds ?d) (faces agent ?c)))<br>          (hold-while (and (in_motion ?d) (not (agent_holds ?d))) (touch ?d ?c))<br>          (once (and (not (in_motion ?d)) (on bed ?d)))<br>       )<br>     )<br>   )<br>    (preference ballThrownHitsAgent<br>      (exists (?d - dodgeball_pink ?c - curved_wooden_ramp)<br>        (then<br>          (once (and (agent_holds ?d) (faces agent ?c)))<br>          (hold-while (and (in_motion ?d) (not (agent_holds ?d))) (touch ?d ?c))<br>          (once (and (touch ?d agent) (not (agent_holds ?d))))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?c of type curved_wooden_ramp<br>    -?d of type dodgeball_pink<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (agent is facing ?c)<br>    - next, there is a sequence of one or more states where (?d is in motion) and (it's not the case that the agent is holding ?d) Additionally, during this sequence there is a state where (?d touches ?c) (in that order).<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is on bed)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?c of type curved_wooden_ramp<br>    -?d of type dodgeball_pink<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (agent is facing ?c)<br>    - next, there is a sequence of one or more states where (?d is in motion) and (it's not the case that the agent is holding ?d) Additionally, during this sequence there is a state where (?d touches ?c) (in that order).<br>    - finally, there is a state where (?d touches agent) and (it's not the case that the agent is holding ?d)                                                                                                                                                                                      </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a pink dodgeball and is facing a curved wooden ramp<br>-next, the agent throws the dodgeball, which then moves and touches the ramp during its flight<br>-finally, the dodgeball stops moving and rests on the bed<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a pink dodgeball and is facing a curved wooden ramp<br>-next, the agent throws the dodgeball, which then moves and touches the ramp during its flight<br>-finally, the dodgeball stops moving and touches the agent without being held by them                                                                                                                                                                                                 </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </td><td>                                                                                                                                                                                     </td><td>                                                                                                                                                                                                </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count ballThrownToRampToBed) (- (count ballThrownHitsAgent))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied) and (negative the number of times 'Preference 2' has been satisfied)</td><td>At the end of the game, the player's score is calculated by adding the number of times Preference 1 has been satisfied and then subtracting the number of times Preference 2 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                               </th><th scope="col">Stage 2                                                                                                                                                                                                                                 </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?g - golfball_green)<br>    (and<br>      (game-conserved<br>        (near door ?g)<br>     )<br>      (forall (?d - dodgeball)<br>        (game-optional<br>          (near ?d ?g)<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>In order to set up the game, there exists an object ?g of type golfball_green, such that the following must all be true for at least one time step:<br>- for any object ?d of type dodgeball, ?d is near ?g<br><br>and in addition, the following must all be true for every time step:<br>- door is near ?g                                                                                                                                                                                                                                                                                       </td><td>In order to set up the game, place a green golf ball near the door and ensure that it remains there throughout the game. Additionally, at least once during the game, make sure that every dodgeball is placed near the green golf ball.</td><td>Setup: place a green golf ball near the door and ensure it stays there for the entire game. Also, at some point during the game, position every dodgeball near the green golf ball.<br><br>Gameplay: hold a dodgeball while standing next to both the green golf ball and the door, then throw the dodgeball so that it moves on its own.<br><br>Terminal: the game ends when a single dodgeball has satisfied Preference 2 more than once or when at least three different objects have satisfied Preference 2.<br><br>Scoring: your score is 10 points for each different object that has been thrown into a hexagonal bin while standing next to the green golf ball and the door.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?d - dodgeball)<br>      (and<br>        (preference dodgeballThrownToBin<br>          (exists (?h - hexagonal_bin ?g - golfball_green)<br>            (then<br>              (once (and (adjacent ?g agent) (adjacent door agent) (agent_holds ?d)))<br>              (hold (and (in_motion ?d) (not (agent_holds ?d))))<br>              (once (and (not (in_motion ?d)) (in ?h ?d)))<br>           )<br>         )<br>       )<br>        (preference throwAttemptFromDoor<br>          (exists (?g - golfball_green)<br>            (then<br>              (once (and (adjacent ?g agent) (adjacent door agent) (agent_holds ?d)))<br>              (hold (and (in_motion ?d) (not (agent_holds ?d))))<br>              (once (not (in_motion ?d)))<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?g of type golfball_green<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (?g is adjacent to agent), (door is adjacent to agent), and (the agent is holding ?d)<br>    - next, there is a sequence of one or more states where (?d is in motion) and (it's not the case that the agent is holding ?d)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)<br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?g of type golfball_green<br><br>    This preference is satisfied when:<br>    - first, there is a state where (?g is adjacent to agent), (door is adjacent to agent), and (the agent is holding ?d)<br>    - next, there is a sequence of one or more states where (?d is in motion) and (it's not the case that the agent is holding ?d)<br>    - finally, there is a state where it's not the case that ?d is in motion                                                                                                                                                                                                                                                                                       </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while both a green golfball and a door are adjacent to the agent<br>-next, the agent throws the dodgeball, which then moves on its own<br>-finally, the dodgeball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while both a green golfball and a door are adjacent to the agent<br>-next, the agent throws the dodgeball, which then moves on its own<br>-finally, the dodgeball stops moving                                                                                                                                                                                                                                         </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (or<br>    (> (external-forall-maximize (count throwAttemptFromDoor)) 1)<br>    (>= (count-once-per-objects throwAttemptFromDoor) 3)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>The game ends when (the maximum value of (the number of times 'Preference 2' has been satisfied) over all quantifications of ?d (of type dodgeball) is greater than 1) or (the number of times 'Preference 2' has been satisfied with different objects is greater than or equal to 3)</td><td>The game ends when Preference 2 has been satisfied more than once with any single dodgeball or when Preference 2 has been satisfied with at least three different objects.                                                              </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (* 10 (count-once-per-objects dodgeballThrownToBin))<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>At the end of the game, the player's score is the product of (10) and (the number of times 'Preference 1' has been satisfied with different objects)                                                                                                                                  </td><td>At the end of the game, the player's score is 10 times the number of different objects that have been used to satisfy Preference 1.                                                                                                     </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                          </th><th scope="col">Stage 1                                                                                                                   </th><th scope="col">Stage 2                                                                                                                                      </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?h - hexagonal_bin)<br>    (game-conserved<br>      (near room_center ?h)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                       </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin, such that room_center is near ?h                                                                                                                           </td><td>In order to set up the game, place a hexagonal bin near the center of the room and ensure that it remains there for the duration of the game.</td><td>Setup: place a hexagonal bin near the center of the room and ensure that it remains there for the duration of the game.<br><br>Gameplay: set game objects in motion so that they end up inside the hexagonal bin without holding them.<br><br>Scoring: you get 1 point for each different object that you successfully get into the bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference gameObjectToBin<br>      (exists (?g - game_object ?h - hexagonal_bin)<br>        (then<br>          (once (not (agent_holds ?g)))<br>          (hold (or (agent_holds ?g) (in_motion ?g)))<br>          (once (and (not (in_motion ?g)) (in ?h ?g)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?g of type game_object<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where it's not the case that the agent is holding ?g<br>    - next, there is a sequence of one or more states where (the agent is holding ?g) or (?g is in motion)<br>    - finally, there is a state where (it's not the case that ?g is in motion) and (?g is inside of ?h)                                                                                                                           </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is not holding a game object<br>-next, the agent picks up the game object or it is set in motion<br>-finally, the game object stops moving and is inside a hexagonal bin                                                                                                                                              </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                 </td><td>                                                                                                                          </td><td>                                                                                                                                             </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count-once-per-objects gameObjectToBin)<br>)</code></pre>                                                                                                                                                                                                                                                                             </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied with different objects</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied using different objects.                   </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 1                                                                                            </th><th scope="col">Stage 2                                                                                           </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                   </td><td>                                                                                                  </td><td>Gameplay: throw dodgeballs so that they land inside a hexagonal bin<br><br>Scoring: you get 1 point for each successful throw that results in a dodgeball stopping inside the bin          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwToBin<br>      (exists (?d - dodgeball ?h - hexagonal_bin)<br>        (then<br>          (once (agent_holds ?d))<br>          (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?d<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)                                                                                                    </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a dodgeball<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving and is inside a hexagonal bin                                                                                                   </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                   </td><td>                                                                                                  </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwToBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                             </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 1                                                                                                                                                                                              </th><th scope="col">Stage 2                                                                                                                                                                        </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>                                                                                                                                                                                                     </td><td>                                                                                                                                                                               </td><td>Gameplay: pick up cube blocks, place them inside buildings, and then either remove them or end the game with them inside.<br><br>Terminal: the game ends after you have picked up and then released a cube block at least three times.<br><br>Scoring: your score is the maximum number of times you placed a cube block inside any building and then either removed it or finished the game with it inside, across all buildings and overlapping intervals.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?b - building)<br>      (and<br>        (preference blockPlacedInBuilding<br>          (exists (?l - cube_block)<br>            (then<br>              (once (agent_holds ?l))<br>              (hold (not (agent_holds ?l)))<br>              (hold (in ?b ?l))<br>              (once (or (not (in ?b ?l)) (game_over)))<br>           )<br>         )<br>       )<br>     )<br>   )<br>    (forall (?l - cube_block)<br>      (and<br>        (preference blockPickedUp<br>          (then<br>            (once (not (agent_holds ?l)))<br>            (hold (agent_holds ?l))<br>            (once (not (agent_holds ?l)))<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type building<br>    -?l of type cube_block<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?l<br>    - next, there is a sequence of one or more states where it's not the case that the agent is holding ?l<br>    - next, there is a sequence of one or more states where ?l is inside of ?b<br>    - finally, there is a state where (it's not the case that ?l is inside of ?b) or (it is the last state in the game)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?l of type cube_block<br><br>    This preference is satisfied when:<br>    - first, there is a state where it's not the case that the agent is holding ?l<br>    - next, there is a sequence of one or more states where the agent is holding ?l<br>    - finally, there is a state where it's not the case that the agent is holding ?l                                                                                                                                                                                                      </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent picks up a cube block<br>-next, the agent is no longer holding the cube block<br>-following that, the cube block is placed inside a building<br>-finally, the cube block is either no longer inside the building or it is the last state of the game<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the cube block is not being held by the agent<br>-next, the agent picks up the cube block<br>-finally, the agent is no longer holding the cube block                                                                                                                                                                                </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (>= (external-forall-maximize (count blockPickedUp)) 3)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>The game ends when the maximum value of (the number of times 'Preference 2' has been satisfied) over all quantifications of ?l (of type cube_block) is greater than or equal to 3                    </td><td>The game ends when Preference 2 has been satisfied at least three times for any instance of the type 'cube_block'.                                                             </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (external-forall-maximize<br>    (count-overlapping blockPlacedInBuilding)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </td><td>At the end of the game, the player's score is the maximum value of (the number of times 'Preference 1' has been satisfied in overlapping intervals) over all quantifications of ?b (of type building)</td><td>At the end of the game, the player's score is equal to the highest number of times Preference 1 was satisfied within overlapping intervals, considering all possible buildings.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                             </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                          </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (and<br>    (forall (?l - block ?s - shelf)<br>      (game-optional<br>        (not<br>          (on ?s ?l)<br>       )<br>     )<br>   )<br>    (exists (?b - building)<br>      (game-conserved<br>        (and<br>          (= (building_size ?b) 6)<br>          (forall (?l - block)<br>            (or<br>              (in ?b ?l)<br>              (exists (?l2 - block)<br>                (and<br>                  (in ?b ?l2)<br>                  (not<br>                    (same_object ?l ?l2)<br>                 )<br>                  (same_type ?l ?l2)<br>               )<br>             )<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>In order to set up the game, the following must all be true for at least one time step:<br>- for any object ?l of type block and object ?s of type shelf, it's not the case that ?l is on ?s<br><br>and in addition, the following must all be true for every time step:<br>- there exists an object ?b of type building, such that (the number of obects in building ?b and 6 are all equal) and (for any object ?l of type block, (?l is inside of ?b) or (there exists an object ?l2 of type block, such that (?l2 is inside of ?b), (it's not the case that ?l is the same object as ?l2), and (?l is of the same type as ?l2)))                                                                                                                                                                                                                                                                                                                                                     </td><td>In order to set up the game, ensure that at some point, no block is placed on any shelf. Additionally, throughout the game, there must be a building that contains exactly six objects. Every block must either be inside this building or be of the same type as another block that is inside the building, provided that no two blocks inside the building are the same object.</td><td>Setup: Ensure no block is on any shelf and maintain a building with exactly six unique objects throughout the game. All blocks must either be in this building or match the type of another block within it.<br><br>Gameplay: Hold blocks without placing them inside the initial building setup. Interact with blocks by holding or moving them, ensuring they touch each other and set one in motion without holding it.<br><br>Scoring: Earn 5 points for each unique object held during the game. Gain 100 points if there is a building from the initial setup and another that is not, with no two blocks inside the setup building stacked on each other unless there are two identical blocks stacked inside the non-setup building. Lose 10 points each time a block is set in motion after touching another block.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference gameBlockFound<br>      (exists (?l - block)<br>        (then<br>          (once (game_start))<br>          (hold (not (exists (?b - building) (and (in ?b ?l) (is_setup_object ?b)))))<br>          (once (agent_holds ?l))<br>       )<br>     )<br>   )<br>    (preference towerFallsWhileBuilding<br>      (exists (?b - building ?l1 ?l2 - block)<br>        (then<br>          (once (and (in ?b ?l1) (agent_holds ?l2) (not (is_setup_object ?b))))<br>          (hold-while (and (not (agent_holds ?l1)) (in ?b ?l1) (or (agent_holds ?l2) (in_motion ?l2))) (touch ?l1 ?l2))<br>          (hold (and (in_motion ?l1) (not (agent_holds ?l1))))<br>          (once (not (in_motion ?l1)))<br>       )<br>     )<br>   )<br>    (preference matchingBuildingBuilt<br>      (exists (?b1 ?b2 - building)<br>        (at-end<br>          (and<br>            (is_setup_object ?b1)<br>            (not<br>              (is_setup_object ?b2)<br>           )<br>            (forall (?l1 ?l2 - block)<br>              (or<br>                (not<br>                  (in ?b1 ?l1)<br>               )<br>                (not<br>                  (in ?b1 ?l2)<br>               )<br>                (not<br>                  (on ?l1 ?l2)<br>               )<br>                (exists (?l3 ?l4 - block)<br>                  (and<br>                    (in ?b2 ?l3)<br>                    (in ?b2 ?l4)<br>                    (on ?l3 ?l4)<br>                    (same_type ?l1 ?l3)<br>                    (same_type ?l2 ?l4)<br>                 )<br>               )<br>             )<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?l of type block<br><br>    This preference is satisfied when:<br>    - first, there is a state where it is the first state in the game<br>    - next, there is a sequence of one or more states where it's not the case that there exists an object ?b of type building, such that (?l is inside of ?b) and (?b is used in the setup)<br>    - finally, there is a state where the agent is holding ?l<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?l1 and ?l2 of type block<br>    -?b of type building<br><br>    This preference is satisfied when:<br>    - first, there is a state where (?l1 is inside of ?b), (the agent is holding ?l2), and (it's not the case that ?b is used in the setup)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?l1), (?l1 is inside of ?b), and ((the agent is holding ?l2) or (?l2 is in motion)) Additionally, during this sequence there is a state where (?l1 touches ?l2) (in that order).<br>    - next, there is a sequence of one or more states where (?l1 is in motion) and (it's not the case that the agent is holding ?l1)<br>    - finally, there is a state where it's not the case that ?l1 is in motion<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?b1 and ?b2 of type building<br><br>    This preference is satisfied when:<br>    - in the final game state, (?b1 is used in the setup); (it's not the case that ?b2 is used in the setup); and (for any object ?l1 of type block and object ?l2 of type block, (it's not the case that ?l1 is inside of ?b1); (it's not the case that ?l2 is inside of ?b1); (it's not the case that ?l2 is on ?l1); or (there exists objects ?l3 and ?l4 of type block, such that (?l3 is inside of ?b2), (?l4 is inside of ?b2), (?l4 is on ?l3), (?l1 is of the same type as ?l3), and (?l2 is of the same type as ?l4)))                                                                                                                                                                                                                                                                                                                                                     </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the game begins<br>-next, throughout the game, no block is placed inside a building that is part of the initial setup<br>-finally, the agent ends up holding a block<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, one block is inside a building and the agent is holding another block, while the building is not part of the initial setup<br>-next, the agent is not holding the first block, which remains inside the building, while the agent either holds or moves the second block, and at some point during this sequence, the two blocks touch each other<br>-then, the first block is set in motion without the agent holding it<br>-finally, the first block comes to a stop<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-at the end of the game, one building is part of the initial setup and the other is not, and for any two blocks, neither is inside the setup building, they are not stacked on each other, or there are two other blocks inside the non-setup building that are of the same type as the first two blocks and are stacked on each other                                                                                                                                                                                                                                                                                                                                                                                  </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td><td>                                                                                                                                                                                                                                                                                                                                                    </td><td>                                                                                                                                                                                                                                                                                                                                                                                 </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 5 (count-once-per-objects gameBlockFound))<br>    (* 100 (count-once matchingBuildingBuilt))<br>    (* -10 (count towerFallsWhileBuilding))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>At the end of the game, the player's score is the sum of (the product of (5) and (the number of times 'Preference 1' has been satisfied with different objects)); (the product of (100) and (min(1, the number of times 'Preference 3' has been satisfied))); and (the product of (-10) and (the number of times 'Preference 2' has been satisfied))</td><td>At the end of the game, the player's score is calculated by adding together the following: 5 points for each different object used to satisfy Preference 1, 100 points if Preference 3 has been satisfied at least once, and subtracting 10 points for each time Preference 2 has been satisfied.                                                                                </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (game-conserved<br>    (and<br>      (exists (?f - flat_block)<br>        (on rug ?f)<br>     )<br>      (forall (?p - pyramid_block)<br>        (on floor ?p)<br>     )<br>      (exists (?p1 - pyramid_block_yellow ?p2 - pyramid_block_red ?p3 - pyramid_block_blue ?h - hexagonal_bin)<br>        (and<br>          (> (distance ?h ?p2) (distance ?h ?p1))<br>          (> (distance ?h ?p3) (distance ?h ?p2))<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                         </td><td>In order to set up the game, the following must all be true for every time step:<br>- (there exists an object ?f of type flat_block, such that ?f is on rug); (for any object ?p of type pyramid_block, ?p is on floor); and (there exists an object ?h of type hexagonal_bin, an object ?p3 of type pyramid_block_blue, an object ?p2 of type pyramid_block_red, and an object ?p1 of type pyramid_block_yellow, such that (the distance between ?h and ?p2 is greater than the distance between ?h and ?p1) and (the distance between ?h and ?p3 is greater than the distance between ?h and ?p2))                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>In order to set up the game, place a flat block on the rug and ensure it remains there for the entire game. Additionally, every pyramid block should be on the floor. Then, position a hexagonal bin and arrange three pyramid blocks of different colorsyellow, red, and bluein increasing distances from the hexagonal bin. Specifically, the yellow pyramid block should be closest to the bin, followed by the red one at a greater distance, and finally, the blue pyramid block should be the farthest from the hexagonal bin. Make sure these distances are maintained throughout the game.</td><td>Setup: Place a flat block on the rug and ensure it remains there for the entire game. Position every pyramid block on the floor and arrange three pyramid blocks of different colorsyellow, red, and bluein increasing distances from a hexagonal bin, with the yellow block being the closest and the blue block being the farthest.<br><br>Gameplay: Hold a dodgeball while standing next to a pyramid block and throw it into the hexagonal bin. Additionally, incorporate a flat block and a cube block into a building as part of the setup.<br><br>Scoring: Earn 10 points for each successful throw of the dodgeball into the bin with the yellow pyramid block, 25 points with the red pyramid block, and 50 points with the blue pyramid block. Also, gain 10 points for each different object used to satisfy the condition of having a flat block and a cube block inside a building. Points related to sections with [SYNTAX ERROR IN SCORING] cannot be calculated due to undefined scoring conditions.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?p - pyramid_block)<br>      (and<br>        (preference dodgeballFromBlockToBin<br>          (exists (?d - dodgeball ?h - hexagonal_bin)<br>            (then<br>              (once (and (agent_holds ?d) (adjacent ?p agent)))<br>              (hold (and (not (agent_holds ?d)) (in_motion ?d)))<br>              (once (and (not (in_motion ?d)) (in ?h ?d)))<br>           )<br>         )<br>       )<br>     )<br>   )<br>    (preference cubeBlockInBuilding<br>      (exists (?b - building ?l - cube_block ?f - flat_block)<br>        (at-end<br>          (and<br>            (is_setup_object ?f)<br>            (in ?b ?f)<br>            (in ?b ?l)<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?p of type pyramid_block<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?d) and (?p is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion)<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type building<br>    -?l of type cube_block<br>    -?f of type flat_block<br><br>    This preference is satisfied when:<br>    - in the final game state, (?f is used in the setup), (?f is inside of ?b), and (?l is inside of ?b)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is holding a dodgeball while a pyramid block is next to the agent<br>-next, the agent throws the dodgeball<br>-finally, the dodgeball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-at the end of the game, a flat block is part of the setup and both the flat block and a cube block are inside a building                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 10 (count dodgeballFromBlockToBin:pyramid_block_yellow))<br>    (* 25 (count dodgeballFromBlockToBin:pyramid_block_red))<br>    (* 50 (count dodgeballFromBlockToBin:pyramid_block_blue))<br>    (* 100 (= (count-once-per-objects dodgeballFromBlockToBin:pyramid_block_blue) 3)<br>   )<br>    (* 10 (count-once-per-objects cubeBlockInBuilding))<br>    (* 100 (= (count-once-per-objects cubeBlockInBuilding) 3)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                      </td><td>At the end of the game, the player's score is the sum of (the product of (10) and (the number of times 'Preference 1' has been satisfied, where ?p is bound to an object of type pyramid_block_yellow)); (the product of (25) and (the number of times 'Preference 1' has been satisfied, where ?p is bound to an object of type pyramid_block_red)); (the product of (50) and (the number of times 'Preference 1' has been satisfied, where ?p is bound to an object of type pyramid_block_blue)); (the product of (100) and ([SYNTAX ERROR IN SCORING])); (the product of (10) and (the number of times 'Preference 2' has been satisfied with different objects)); and (the product of (100) and ([SYNTAX ERROR IN SCORING]))</td><td>At the end of the game, the player's score is calculated by adding together the following points: 10 points for each time Preference 1 is satisfied with a yellow pyramid block, 25 points for each time Preference 1 is satisfied with a red pyramid block, and 50 points for each time Preference 1 is satisfied with a blue pyramid block. Additionally, the player earns 10 points for each different object used to satisfy Preference 2. Points related to the sections with [SYNTAX ERROR IN SCORING] cannot be calculated as the scoring conditions are not properly defined.               </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                  </th><th scope="col">Stage 2                                                                                                                                                                                                                                                          </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>                                                                                                                                                                                                                                                                                         </td><td>                                                                                                                                                                                                                                                                 </td><td>Gameplay: While standing next to a desk, pick up and release objects to set them into motion. Chairs, laptops, or doggie beds should come to rest on the bed, while other objects can either land on the bed or elsewhere.<br><br>Scoring: Your score is determined by the number of successful placements on the bed, with each chair, laptop, or doggie bed placement on the bed worth 5 points, and other objects placed on the bed worth 1 point. However, 5 points are subtracted for each object that comes to rest somewhere other than the bed.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference bigObjectThrownToBed<br>      (exists (?o - (either chair laptop doggie_bed))<br>        (then<br>          (once (and (agent_holds ?o) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?o)) (in_motion ?o)))<br>          (once (and (not (in_motion ?o)) (on bed ?o)))<br>       )<br>     )<br>   )<br>    (preference smallObjectThrownToBed<br>      (exists (?o - game_object)<br>        (then<br>          (once (and (agent_holds ?o) (adjacent desk agent) (not (exists (?o2 - (either chair laptop doggie_bed)) (same_object ?o ?o2)))))<br>          (hold (and (not (agent_holds ?o)) (in_motion ?o)))<br>          (once (and (not (in_motion ?o)) (on bed ?o)))<br>       )<br>     )<br>   )<br>    (preference failedThrowAttempt<br>      (exists (?o - game_object)<br>        (then<br>          (once (and (agent_holds ?o) (adjacent desk agent)))<br>          (hold (and (not (agent_holds ?o)) (in_motion ?o)))<br>          (once (and (not (in_motion ?o)) (not (on bed ?o))))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?o of type chair, laptop, or doggie_bed<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?o) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?o) and (?o is in motion)<br>    - finally, there is a state where (it's not the case that ?o is in motion) and (?o is on bed)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?o of type game_object<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?o); (desk is adjacent to agent); and (it's not the case that there exists an object ?o2 of type chair, laptop, or doggie_bed, such that ?o is the same object as ?o2)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?o) and (?o is in motion)<br>    - finally, there is a state where (it's not the case that ?o is in motion) and (?o is on bed)<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?o of type game_object<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?o) and (desk is adjacent to agent)<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?o) and (?o is in motion)<br>    - finally, there is a state where (it's not the case that ?o is in motion) and (it's not the case that ?o is on bed)                                                                                                                                                                                                                                                                                          </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent picks up an object that is either a chair, laptop, or doggie bed while standing next to a desk<br>-next, the agent releases the object, setting it into motion<br>-finally, the object comes to rest on the bed<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds an object that is not a chair, laptop, or doggie bed while standing next to a desk<br>-next, the agent throws or places the object, causing it to move<br>-finally, the object stops moving and is found on the bed<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-first, the agent picks up any object while standing next to a desk<br>-next, the agent releases the object, allowing it to move<br>-finally, the object stops moving and is not on the bed                                                                                                                                                                                                                                                                  </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>                                                                                                                                                                                                                                                                                         </td><td>                                                                                                                                                                                                                                                                 </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count smallObjectThrownToBed) (* 5 (count bigObjectThrownToBed))<br>    (* -5 (count failedThrowAttempt))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 2' has been satisfied), (the product of (5) and (the number of times 'Preference 1' has been satisfied)), and (the product of (-5) and (the number of times 'Preference 3' has been satisfied))</td><td>At the end of the game, the player's score is calculated by adding the number of times Preference 2 has been satisfied, 5 times the number of times Preference 1 has been satisfied, and subtracting 5 times the number of times Preference 3 has been satisfied.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                            </th><th scope="col">Stage 1                                                                                                                   </th><th scope="col">Stage 2                                                                                                                  </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                   </td><td>                                                                                                                          </td><td>                                                                                                                         </td><td>Gameplay: place balls on the bed<br><br>Scoring: you get 1 point for each different ball placed on the bed by the end of the game          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballOnBedAtEnd<br>      (exists (?b - ball)<br>        (at-end<br>          (on bed ?b)<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br><br>    This preference is satisfied when:<br>    - in the final game state, ?b is on bed                                                                                                                           </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-at the end of the game, a ball is on the bed                                                                                                                          </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                   </td><td>                                                                                                                          </td><td>                                                                                                                         </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count-once-per-objects ballOnBedAtEnd)<br>)</code></pre>                                                                                                                </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied with different objects</td><td>At the end of the game, the player's score is the number of distinct objects that have been used to satisfy Preference 1.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                </th><th scope="col">Stage 1                                                                                            </th><th scope="col">Stage 2                                                                                                                                            </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?c - curved_wooden_ramp ?h - hexagonal_bin)<br>    (game-conserved<br>      (adjacent ?c ?h)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                          </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?c of type curved_wooden_ramp and an object ?h of type hexagonal_bin, such that ?c is adjacent to ?h                                                                                                    </td><td>In order to set up the game, place a curved wooden ramp next to a hexagonal bin and ensure that this arrangement is maintained throughout the game.</td><td>Setup: place a curved wooden ramp next to a hexagonal bin and ensure that this arrangement is maintained throughout the game.<br><br>Gameplay: hold a dodgeball, throw it so that it touches the curved wooden ramp during its flight, and ensure it lands and stops inside the hexagonal bin.<br><br>Scoring: your score is the number of successful throws where the dodgeball touches the ramp and then stops inside the bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballThrownThroughRampToBin<br>      (exists (?d - dodgeball ?c - curved_wooden_ramp ?h - hexagonal_bin)<br>        (then<br>          (once (agent_holds ?d))<br>          (hold-while (and (not (agent_holds ?d)) (in_motion ?d)) (touch ?d ?c))<br>          (once (and (not (in_motion ?d)) (in ?h ?d)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?c of type curved_wooden_ramp<br>    -?d of type dodgeball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?d<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?d) and (?d is in motion) Additionally, during this sequence there is a state where (?d touches ?c) (in that order).<br>    - finally, there is a state where (it's not the case that ?d is in motion) and (?d is inside of ?h)                                                                                                    </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a dodgeball<br>-next, the agent throws the dodgeball, and during its flight, the dodgeball touches a curved wooden ramp<br>-finally, the dodgeball stops moving and is inside a hexagonal bin                                                                                                                                                    </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                       </td><td>                                                                                                   </td><td>                                                                                                                                                   </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count ballThrownThroughRampToBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                         </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied</td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.                                                 </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (and<br>    (forall (?c - chair)<br>      (game-conserved<br>        (not<br>          (adjacent_side desk front ?c)<br>       )<br>     )<br>   )<br>    (exists (?h - hexagonal_bin ?c - curved_wooden_ramp)<br>      (game-conserved<br>        (and<br>          (adjacent_side desk front ?c)<br>          (adjacent_side ?h front ?c back)<br>       )<br>     )<br>   )<br>    (forall (?o - (either golfball dodgeball triangle_block pyramid_block))<br>      (game-optional<br>        (near side_table ?o)<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>In order to set up the game, the following must all be true for at least one time step:<br>- for any object ?o of type golfball, dodgeball, triangle_block, or pyramid_block, side_table is near ?o<br><br>and in addition, the following must all be true for every time step:<br>- for any object ?c of type chair, it's not the case that ?c is adjacent to the front of desk<br>- there exists an object ?c of type curved_wooden_ramp and an object ?h of type hexagonal_bin, such that (?c is adjacent to the front of desk) and (the front of ?h is adjacent to the back of ?c)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td><td>In order to set up the game, place any object that is a golfball, dodgeball, triangle block, or pyramid block near the side table at least once. Additionally, throughout the entire game, ensure that no chair is placed adjacent to the front of the desk. Also, position a curved wooden ramp adjacent to the front of the desk and a hexagonal bin with its front side adjacent to the back of the curved wooden ramp, and make sure these remain in place for the duration of the game.                                                         </td><td>Setup: Place golfballs, dodgeballs, triangle blocks, or pyramid blocks near the side table and ensure no chair is adjacent to the front of the desk. Position a curved wooden ramp adjacent to the front of the desk and a hexagonal bin with its front side adjacent to the back of the ramp, maintaining their placement throughout the game.<br><br>Gameplay: While next to the bed, throw golfballs, dodgeballs, triangle blocks, or pyramid blocks aiming for them to either land inside a hexagonal bin or touch a desktop or laptop. Additionally, throw golfballs so they touch the curved wooden ramp before landing in the hexagonal bin.<br><br>Scoring: Earn 1 point for each triangle block, 2 points for each pyramid block or dodgeball, and 3 points for each golfball that lands in the hexagonal bin. Earn 6 points for each golfball that touches the curved wooden ramp and then lands in the hexagonal bin. Lose 1 point for each object that comes to rest touching a desktop or laptop. The final score is the total of these points.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?o - (either golfball dodgeball triangle_block pyramid_block))<br>      (and<br>        (preference objectLandsInBin<br>          (exists (?h - hexagonal_bin)<br>            (then<br>              (once (and (adjacent bed agent) (agent_holds ?o)))<br>              (hold (and (in_motion ?o) (not (agent_holds ?o))))<br>              (once (and (not (in_motion ?o)) (in ?h ?o)))<br>           )<br>         )<br>       )<br>        (preference thrownObjectHitsComputer<br>          (exists (?c - (either desktop laptop))<br>            (then<br>              (once (and (adjacent bed agent) (agent_holds ?o)))<br>              (hold (and (in_motion ?o) (not (agent_holds ?o))))<br>              (once (touch ?o ?c))<br>           )<br>         )<br>       )<br>     )<br>   )<br>    (preference golfballLandsInBinThroughRamp<br>      (exists (?g - golfball ?c - curved_wooden_ramp ?h - hexagonal_bin)<br>        (then<br>          (once (and (adjacent bed agent) (agent_holds ?g)))<br>          (hold-while (and (in_motion ?g) (not (agent_holds ?g))) (touch ?c ?g))<br>          (once (and (not (in_motion ?g)) (in ?h ?g)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?o of type golfball, dodgeball, triangle_block, or pyramid_block<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (bed is adjacent to agent) and (the agent is holding ?o)<br>    - next, there is a sequence of one or more states where (?o is in motion) and (it's not the case that the agent is holding ?o)<br>    - finally, there is a state where (it's not the case that ?o is in motion) and (?o is inside of ?h)<br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?o of type golfball, dodgeball, triangle_block, or pyramid_block<br>    -?c of type desktop or laptop<br><br>    This preference is satisfied when:<br>    - first, there is a state where (bed is adjacent to agent) and (the agent is holding ?o)<br>    - next, there is a sequence of one or more states where (?o is in motion) and (it's not the case that the agent is holding ?o)<br>    - finally, there is a state where ?o touches ?c<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?c of type curved_wooden_ramp<br>    -?g of type golfball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (bed is adjacent to agent) and (the agent is holding ?g)<br>    - next, there is a sequence of one or more states where (?g is in motion) and (it's not the case that the agent is holding ?g) Additionally, during this sequence there is a state where (?c touches ?g) (in that order).<br>    - finally, there is a state where (it's not the case that ?g is in motion) and (?g is inside of ?h)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is next to the bed and holds an object, which can be a golfball, dodgeball, triangle block, or pyramid block<br>-next, the agent throws the object<br>-finally, the object stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent is next to the bed and holds an object, which can be a golfball, dodgeball, triangle block, or pyramid block<br>-next, the agent throws the object<br>-finally, the object comes to rest touching a desktop or laptop<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-first, the agent is next to the bed and holds a golfball<br>-next, the agent throws the golfball, which at some point during its motion, touches a curved wooden ramp<br>-finally, the golfball stops moving and is inside a hexagonal bin                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                      </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                              </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count objectLandsInBin:triangle_block) (* 2 (count objectLandsInBin:pyramid_block))<br>    (* 2 (count objectLandsInBin:dodgeball))<br>    (* 3 (count objectLandsInBin:golfball))<br>    (* 6 (count golfballLandsInBinThroughRamp))<br>    (- (count thrownObjectHitsComputer))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type triangle_block); (the product of (2) and (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type pyramid_block)); (the product of (2) and (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type dodgeball)); (the product of (3) and (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type golfball)); (the product of (6) and (the number of times 'Preference 3' has been satisfied)); and (negative the number of times 'Preference 2' has been satisfied)</td><td>At the end of the game, the player's score is calculated by adding the following: 1 point for each time Preference 1 is satisfied with a triangle block, 2 points for each time Preference 1 is satisfied with a pyramid block, 2 points for each time Preference 1 is satisfied with a dodgeball, 3 points for each time Preference 1 is satisfied with a golfball, and 6 points for each time Preference 3 is satisfied. However, the player loses a point for each time Preference 2 is satisfied. The final score is the sum of all these points.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </th><th scope="col">Stage 1                                                                                                                                                                                          </th><th scope="col">Stage 2                                                                                                                      </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>                                                                                                                                                                                                 </td><td>                                                                                                                             </td><td>Gameplay: stand next to a hexagonal bin and throw balls with the goal of getting them to land inside the bin.<br><br>Terminal: the game ends after you've thrown balls at least five times or after at least one ball has landed in the hexagonal bin.<br><br>Scoring: your score is 5 points for each ball that successfully lands in the hexagonal bin.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballDroppedInBin<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (and (adjacent ?h agent) (agent_holds ?b)))<br>          (hold (and (in_motion ?b) (not (agent_holds ?b))))<br>          (once (and (not (in_motion ?b)) (in ?h ?b)))<br>       )<br>     )<br>   )<br>    (preference dropAttempt<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (and (adjacent ?h agent) (agent_holds ?b)))<br>          (hold (and (in_motion ?b) (not (agent_holds ?b))))<br>          (once (not (in_motion ?b)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (?h is adjacent to agent) and (the agent is holding ?b)<br>    - next, there is a sequence of one or more states where (?b is in motion) and (it's not the case that the agent is holding ?b)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (?h is adjacent to agent) and (the agent is holding ?b)<br>    - next, there is a sequence of one or more states where (?b is in motion) and (it's not the case that the agent is holding ?b)<br>    - finally, there is a state where it's not the case that ?b is in motion                                                                                                                                                                                                  </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent is next to a hexagonal bin and is holding a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving and is inside the hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent is next to a hexagonal bin and is holding a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving                                                                                                                              </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (or<br>    (>= (count dropAttempt) 5)<br>    (>= (count ballDroppedInBin) 1)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                             </td><td>The game ends when (the number of times 'Preference 2' has been satisfied is greater than or equal to 5) or (the number of times 'Preference 1' has been satisfied is greater than or equal to 1)</td><td>The game ends when Preference 2 has been satisfied at least five times or when Preference 1 has been satisfied at least once.</td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (* 5 (count ballDroppedInBin))<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>At the end of the game, the player's score is the product of (5) and (the number of times 'Preference 1' has been satisfied)                                                                     </td><td>At the end of the game, the player's score is 5 times the number of times Preference 1 has been satisfied.                   </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                              </th><th scope="col">Stage 2                                                                                                                                                                                                      </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?h - hexagonal_bin ?w - wall)<br>    (game-conserved<br>      (and<br>        (on desk ?h)<br>        (adjacent ?h ?w)<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                          </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin and an object ?w of type wall, such that (?h is on desk) and (?h is adjacent to ?w)                                                                                                                                                                                                                                                                                                      </td><td>In order to set up the game, place a hexagonal bin on the desk next to a wall and ensure that it remains in this position for the duration of the game.                                                      </td><td>Setup: place a hexagonal bin on the desk next to a wall and ensure it stays there throughout the game.<br><br>Gameplay: while standing on the rug, throw either a dodgeball or a block so that it lands inside the hexagonal bin.<br><br>Scoring: your score is the total number of successful throws with a dodgeball plus twice the number of successful throws with a block.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (forall (?o - (either dodgeball block))<br>      (and<br>        (preference basketMadeFromRug<br>          (exists (?h - hexagonal_bin)<br>            (then<br>              (once (and (agent_holds ?o) (on rug agent)))<br>              (hold (and (in_motion ?o) (not (agent_holds ?o))))<br>              (once (and (not (in_motion ?o)) (in ?h ?o)))<br>           )<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?o of type dodgeball or block<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where (the agent is holding ?o) and (agent is on rug)<br>    - next, there is a sequence of one or more states where (?o is in motion) and (it's not the case that the agent is holding ?o)<br>    - finally, there is a state where (it's not the case that ?o is in motion) and (?o is inside of ?h)                                                                                                                                                                                                                                                                                                      </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds either a dodgeball or a block while standing on the rug<br>-next, the agent throws the object, which then moves on its own<br>-finally, the object comes to rest inside a hexagonal bin                                                                                                                                                                                                              </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                                                                                                                                                                                                                     </td><td>                                                                                                                                                                                                             </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count basketMadeFromRug:dodgeball) (* 2 (count basketMadeFromRug:block))<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                             </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type dodgeball) and (the product of (2) and (the number of times 'Preference 1' has been satisfied, where ?o is bound to an object of type block))</td><td>At the end of the game, the player's score is the total of the number of times Preference 1 has been satisfied with a dodgeball, plus twice the number of times Preference 1 has been satisfied with a block.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                         </th><th scope="col">Stage 1                                                                                                                                                   </th><th scope="col">Stage 2                                                                                                         </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </td><td>                                                                                                                                                          </td><td>                                                                                                                </td><td>Gameplay: throw balls into a hexagonal bin<br><br>Terminal: the game ends once you've scored 6 or more points, or after you've made at least 15 throw attempts<br><br>Scoring: your score is equal to the number of successful throws that land inside the hexagonal bin          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference throwInBin<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (and (not (in_motion ?b)) (in ?h ?b)))<br>       )<br>     )<br>   )<br>    (preference throwAttempt<br>      (exists (?b - ball)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (not (in_motion ?b)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where it's not the case that ?b is in motion                                                                                                                                                           </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving                                                                                                                 </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (or<br>    (>= (total-score) 6)<br>    (>= (count throwAttempt) 15)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td><td>The game ends when ((total-score) is greater than or equal to 6) or (the number of times 'Preference 2' has been satisfied is greater than or equal to 15)</td><td>The game ends when the total score reaches 6 or more, or when Preference 2 has been satisfied at least 15 times.</td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (count throwInBin)<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>At the end of the game, the player's score is the number of times 'Preference 1' has been satisfied                                                       </td><td>At the end of the game, the player's score is the number of times Preference 1 has been satisfied.              </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 2                                                                                                                                                              </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                                                                                     </td><td>Gameplay: throw balls into a hexagonal bin, place or throw cube blocks onto the top shelf, and move pillows onto the doggie bed without holding them.<br><br>Scoring: your score is the sum of the number of different balls thrown into the bin, cube blocks placed or thrown onto the top shelf, and pillows moved onto the doggie bed.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference ballThrownToBin<br>      (exists (?b - ball ?h - hexagonal_bin)<br>        (then<br>          (once (agent_holds ?b))<br>          (hold (and (not (agent_holds ?b)) (in_motion ?b)))<br>          (once (and (not (in_motion ?b)) (in ?h ?b)))<br>       )<br>     )<br>   )<br>    (preference cubeBlockThrownToTopShelf<br>      (exists (?c - cube_block)<br>        (then<br>          (once (agent_holds ?c))<br>          (hold (and (not (agent_holds ?c)) (in_motion ?c)))<br>          (once (and (not (in_motion ?c)) (on top_shelf ?c)))<br>       )<br>     )<br>   )<br>    (preference pillowThrownToDoggieBed<br>      (exists (?p - pillow ?d - doggie_bed)<br>        (then<br>          (once (agent_holds ?p))<br>          (hold (and (not (agent_holds ?p)) (in_motion ?p)))<br>          (once (and (not (in_motion ?p)) (on ?d ?p)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?b<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?b) and (?b is in motion)<br>    - finally, there is a state where (it's not the case that ?b is in motion) and (?b is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?c of type cube_block<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?c<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?c) and (?c is in motion)<br>    - finally, there is a state where (it's not the case that ?c is in motion) and (?c is on top_shelf)<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?d of type doggie_bed<br>    -?p of type pillow<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?p<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?p) and (?p is in motion)<br>    - finally, there is a state where (it's not the case that ?p is in motion) and (?p is on ?d)                                                                                                                                                                                                                                                                                                            </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a ball<br>-next, the agent throws the ball<br>-finally, the ball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a cube block<br>-next, the agent places or throws the cube block<br>-finally, the cube block stops moving and is on the top shelf<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-first, the agent holds a pillow<br>-next, the agent moves the pillow without holding it<br>-finally, the pillow stops moving and is on the doggie bed                                                                                                                                                                      </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>                                                                                                                                                                                                                                                                                                           </td><td>                                                                                                                                                                     </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (count-once-per-objects ballThrownToBin) (count-once-per-objects cubeBlockThrownToTopShelf) (count-once-per-objects pillowThrownToDoggieBed))<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>At the end of the game, the player's score is the sum of (the number of times 'Preference 1' has been satisfied with different objects), (the number of times 'Preference 2' has been satisfied with different objects), and (the number of times 'Preference 3' has been satisfied with different objects)</td><td>At the end of the game, the player's score is the total number of times Preference 1, Preference 2, and Preference 3 have each been satisfied with different objects.</td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </th><th scope="col">Stage 1                                                                                                                                                                                              </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (and<br>    (exists (?c - chair ?r - triangular_ramp ?t - teddy_bear ?h - hexagonal_bin)<br>      (and<br>        (game-conserved<br>          (and<br>            (near room_center ?r)<br>            (adjacent_side ?r front ?c)<br>            (between ?h ?c ?r)<br>            (forall (?b - ball)<br>              (near ?b ?h)<br>           )<br>         )<br>       )<br>        (game-optional<br>          (and<br>            (on ?c ?t)<br>         )<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                               </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?c of type chair, an object ?h of type hexagonal_bin, an object ?t of type teddy_bear, and an object ?r of type triangular_ramp, such that the following must all be true for at least one time step:<br>- (?t is on ?c)<br><br>and in addition, the following must all be true for every time step:<br>- (room_center is near ?r); (?c is adjacent to the front of ?r); (?c is between ?h and ?r); and (for any object ?b of type ball, ?b is near ?h)                                                                                                                                                                                                      </td><td>In order to set up the game, place a chair, a hexagonal bin, a teddy bear, and a triangular ramp in the room. Ensure that at some point, the teddy bear is placed on the chair. Throughout the game, the triangular ramp should be near the center of the room, the chair should be adjacent to the front of the ramp, and positioned between the ramp and the hexagonal bin. Additionally, any ball should be placed near the hexagonal bin and remain there for the duration of the game.</td><td>Setup: Place a chair, a hexagonal bin, a teddy bear, and a triangular ramp in the room. Position the teddy bear on the chair, the triangular ramp near the center of the room, the chair adjacent to the front of the ramp, and any ball near the hexagonal bin, ensuring they all remain in these positions throughout the game.<br><br>Gameplay: Pick up the teddy bear from the chair and throw it so that it either lands inside the hexagonal bin or comes to rest touching a ball.<br><br>Scoring: You earn 5 points each time the teddy bear lands inside the hexagonal bin and 1 point each time it comes to rest touching a ball. Your final score is the sum of these points.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference teddyBearLandsInBin<br>      (exists (?t - teddy_bear ?h - hexagonal_bin ?c - chair)<br>        (then<br>          (once (on ?c ?t))<br>          (hold (agent_holds ?t))<br>          (hold (and (not (agent_holds ?t)) (in_motion ?t)))<br>          (once (and (not (in_motion ?t)) (in ?h ?t)))<br>       )<br>     )<br>   )<br>    (preference teddyBearHitsBall<br>      (exists (?t - teddy_bear ?b - ball ?c - chair)<br>        (then<br>          (once (on ?c ?t))<br>          (hold (agent_holds ?t))<br>          (hold (and (not (agent_holds ?t)) (in_motion ?t)))<br>          (once (touch ?t ?b))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?c of type chair<br>    -?h of type hexagonal_bin<br>    -?t of type teddy_bear<br><br>    This preference is satisfied when:<br>    - first, there is a state where ?t is on ?c<br>    - next, there is a sequence of one or more states where the agent is holding ?t<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?t) and (?t is in motion)<br>    - finally, there is a state where (it's not the case that ?t is in motion) and (?t is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?b of type ball<br>    -?c of type chair<br>    -?t of type teddy_bear<br><br>    This preference is satisfied when:<br>    - first, there is a state where ?t is on ?c<br>    - next, there is a sequence of one or more states where the agent is holding ?t<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?t) and (?t is in motion)<br>    - finally, there is a state where ?t touches ?b                                                                                                                                                                                                      </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, a teddy bear is placed on a chair<br>-next, the agent picks up the teddy bear<br>-then, the agent throws the teddy bear<br>-finally, the teddy bear stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, a teddy bear is placed on a chair<br>-next, the agent picks up the teddy bear<br>-then, the agent throws the teddy bear<br>-finally, the teddy bear comes to rest touching a ball                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>         </td></tr><br><tr><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>                                                                                                                                                                                                     </td><td>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 5 (count teddyBearLandsInBin))<br>    (count teddyBearHitsBall)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          </td><td>At the end of the game, the player's score is the sum of (the product of (5) and (the number of times 'Preference 1' has been satisfied)) and (the number of times 'Preference 2' has been satisfied)</td><td>At the end of the game, the player's score is calculated by adding 5 points for each time Preference 1 has been satisfied to the number of times Preference 2 has been satisfied.                                                                                                                                                                                                                                                                                                          </td><td>         </td></tr><br></tbody>
</table>
<table class="table table-striped table-bordered">
<thead class="thead-dark">
<tr><th scope="col">Stage 0                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                     </th><th scope="col">Stage 1                                                                                                                                                                                                                                                                                                                                                                                                                                         </th><th scope="col">Stage 2                                                                                                                                                                                                                                                                                                                                                                                                    </th><th scope="col">Stage 3  </th></tr>
</thead>
<tbody><br><tr><td><pre><code>(:setup<br>  (exists (?h - hexagonal_bin ?r - triangular_ramp)<br>    (game-conserved<br>      (and<br>        (near ?h ?r)<br>        (not<br>          (adjacent ?h ?r)<br>       )<br>     )<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  </td><td>In order to set up the game, the following must all be true for every time step:<br>- there exists an object ?h of type hexagonal_bin and an object ?r of type triangular_ramp, such that (?h is near ?r) and (it's not the case that ?h is adjacent to ?r)                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>In order to set up the game, place a hexagonal bin and a triangular ramp close to each other, but not directly next to each other, and ensure they remain in that arrangement for the duration of the game.                                                                                                                                                                                                </td><td>Setup: place a hexagonal bin and a triangular ramp close to each other, but not directly next to each other, and ensure they remain in that arrangement for the duration of the game.<br><br>Gameplay: hold a red dodgeball and throw it into the hexagonal bin without it touching the floor.<br><br>Terminal: the game ends after you've thrown the red dodgeball at least 10 times, or as soon as you successfully throw it into the hexagonal bin, whether it touches the floor or not.<br><br>Scoring: you get 5 points if you successfully throw the red dodgeball into the hexagonal bin at least once. Additionally, you earn 2 points for each throw, up to 4 throws, if you have also successfully thrown the red dodgeball into the bin without it touching the floor at least once.          </td></tr><br><tr><td><pre><code>(:constraints<br>  (and<br>    (preference redDodgeballThrownToBinWithoutTouchingFloor<br>      (exists (?h - hexagonal_bin ?r - dodgeball_red)<br>        (then<br>          (once (agent_holds ?r))<br>          (hold (and (not (agent_holds ?r)) (in_motion ?r) (not (touch floor ?r))))<br>          (once (and (not (in_motion ?r)) (in ?h ?r)))<br>       )<br>     )<br>   )<br>    (preference redDodgeballThrownToBin<br>      (exists (?h - hexagonal_bin ?r - dodgeball_red)<br>        (then<br>          (once (agent_holds ?r))<br>          (hold (and (not (agent_holds ?r)) (in_motion ?r)))<br>          (once (and (not (in_motion ?r)) (in ?h ?r)))<br>       )<br>     )<br>   )<br>    (preference throwAttempt<br>      (exists (?r - dodgeball_red)<br>        (then<br>          (once (agent_holds ?r))<br>          (hold (and (not (agent_holds ?r)) (in_motion ?r)))<br>          (once (not (in_motion ?r)))<br>       )<br>     )<br>   )<br> )<br>)</code></pre></td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>    The variables required by this preference are:<br>    -?r of type dodgeball_red<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?r<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?r), (?r is in motion), and (it's not the case that floor touches ?r)<br>    - finally, there is a state where (it's not the case that ?r is in motion) and (?r is inside of ?h)<br><br>-----Preference 2-----<br>    The variables required by this preference are:<br>    -?r of type dodgeball_red<br>    -?h of type hexagonal_bin<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?r<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?r) and (?r is in motion)<br>    - finally, there is a state where (it's not the case that ?r is in motion) and (?r is inside of ?h)<br><br>-----Preference 3-----<br>    The variables required by this preference are:<br>    -?r of type dodgeball_red<br><br>    This preference is satisfied when:<br>    - first, there is a state where the agent is holding ?r<br>    - next, there is a sequence of one or more states where (it's not the case that the agent is holding ?r) and (?r is in motion)<br>    - finally, there is a state where it's not the case that ?r is in motion                                                                                                                                                                                                                                                                                                                                                                                                                                                 </td><td>The preferences of the game are:<br><br>-----Preference 1-----<br>This preference is satisfied when:<br>-first, the agent holds a red dodgeball<br>-next, the agent throws the red dodgeball without it touching the floor<br>-finally, the red dodgeball stops moving and is inside a hexagonal bin<br><br>-----Preference 2-----<br>This preference is satisfied when:<br>-first, the agent holds a red dodgeball<br>-next, the agent throws the red dodgeball<br>-finally, the red dodgeball stops moving and is inside a hexagonal bin<br><br>-----Preference 3-----<br>This preference is satisfied when:<br>-first, the agent holds a red dodgeball<br>-next, the agent throws the red dodgeball<br>-finally, the red dodgeball stops moving                                                                                                                                                                                                                                                                                                                                                                                                            </td><td>         </td></tr><br><tr><td><pre><code>(:terminal<br>  (or<br>    (>= (count throwAttempt) 10)<br>    (>= (count-once redDodgeballThrownToBinWithoutTouchingFloor) 1)<br>    (>= (count-once redDodgeballThrownToBin) 1)<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        </td><td>The game ends when (the number of times 'Preference 3' has been satisfied is greater than or equal to 10); (min(1, the number of times 'Preference 1' has been satisfied) is greater than or equal to 1); or (min(1, the number of times 'Preference 2' has been satisfied) is greater than or equal to 1)                                                                                                                                      </td><td>The game ends when Preference 3 has been satisfied at least 10 times, or when Preference 1 has been satisfied at least once, or when Preference 2 has been satisfied at least once.                                                                                                                                                                                                                        </td><td>         </td></tr><br><tr><td><pre><code>(:scoring<br>  (+ (* 5 (count-once redDodgeballThrownToBin))<br>    (* 3 (= (count throwAttempt) 1)<br>      (count-once redDodgeballThrownToBinWithoutTouchingFloor)<br>   )<br>    (* 2 (< (count throwAttempt) 5)<br>      (count-once redDodgeballThrownToBinWithoutTouchingFloor)<br>   )<br> )<br>)</code></pre>                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           </td><td>At the end of the game, the player's score is the sum of (the product of (5) and (min(1, the number of times 'Preference 2' has been satisfied))); (the product of (3); ([SYNTAX ERROR IN SCORING]); and (min(1, the number of times 'Preference 1' has been satisfied))); and (the product of (2); (the number of times 'Preference 3' has been satisfied is less than 5); and (min(1, the number of times 'Preference 1' has been satisfied)))</td><td>At the end of the game, the player's score is calculated as follows: the player gets 5 points if Preference 2 has been satisfied at least once. Due to a syntax error, the scoring condition involving Preference 1 cannot be determined. Additionally, the player gets 2 points for each time Preference 3 has been satisfied, up to 4 times, provided that Preference 1 has been satisfied at least once.</td><td>         </td></tr><br></tbody>
</table>
    </div>
    <script src="https://code.jquery.com/jquery-3.2.1.slim.min.js" integrity="sha384-KJ3o2DKtIkvYIK3UENzmM7KCkRr/rE9/Qpg6aAZGJwFDMVNA/GpGFF93hXpG5KkN" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/popper.js@1.12.9/dist/umd/popper.min.js" integrity="sha384-ApNbgh9B+Y1QKtv3Rn7W3mgPxhU9K/ScQsAP7hUibX39j7fakFPskvXusvfa0b4Q" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/bootstrap@4.0.0/dist/js/bootstrap.min.js" integrity="sha384-JZR6Spejh4U02d8jOt6vLEHfe/JQGiRRSQQxSfFWpi1MquVdAyjUar5+76PVCmYl" crossorigin="anonymous"></script>
</body>
